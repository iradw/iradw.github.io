(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{513:function(n,t,a){"use strict";a.r(t);var s=a(4),e=Object(s.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"typescript的接口与泛型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript的接口与泛型"}},[n._v("#")]),n._v(" TypeScript的接口与泛型")]),n._v(" "),a("h2",{attrs:{id:"属性类型接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#属性类型接口"}},[n._v("#")]),n._v(" 属性类型接口")]),n._v(" "),a("p",[n._v("对函数的参数进行检查，如果有一个方法"),a("code",[n._v("printName()")]),n._v("要求参数是一个对象，对象中必须包含"),a("code",[n._v("firstName")]),n._v("和"),a("code",[n._v("lastName")]),n._v("两个字符串类型的属性，age属性是可选的数值类型，则可这样写")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("interface nameOption {\n    firstName: string,\n    lastName: string,\n    age?: number\n}\nfunction printName(name: nameOption){\n    console.log(name.firstName + ' ' + name.lastName)\n}\n")])])]),a("hr"),n._v(" "),a("h2",{attrs:{id:"函数类型接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数类型接口"}},[n._v("#")]),n._v(" 函数类型接口")]),n._v(" "),a("p",[n._v("对方法传入的参数以及返回值进行约束")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("interface IPrintName{\n    (firstName:string, lastName:string):string\n}\n")])])]),a("p",[n._v("这个接口可以理解为一个函数模板，参数必须为两个字符串，返回值也是一个字符串。注意：如果想让函数实现函数接口必须按照下面这样进行赋值的函数定义方法，这样才能既指定函数接口，又指定函数返回值。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("const prrintName:IPrintName = (firstName:string, lastName:string):string => firstName + ' ' + lastName\n")])])]),a("p",[n._v("也就是说接口是用来规范方法定义的，他可以批量约束；方法里面的参数类型是用来规范方法调用的。")]),n._v(" "),a("hr"),n._v(" "),a("h2",{attrs:{id:"类类型接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类类型接口"}},[n._v("#")]),n._v(" 类类型接口")]),n._v(" "),a("p",[n._v("这个类类型接口起始就是上面两种接口的整合，类里面有属性和方法。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("interface IAnimal{\n     name: string,\n     eat(food: string): string\n}\n")])])]),a("p",[n._v("这样创建一个类，使用"),a("code",[n._v("implements")]),n._v("实现接口，这个类里面就必须用name属性和eat方法，其中eat方法必须是传入字符串参数返回字符串。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("class Dog implements IAnimal{\n    name: string\n    constructor(name:string){\n          this.name = name\n    }\n    eat(food:string){\n          return this.name+'吃'+food\n    }\n}\nconst dog = new Dog('旺财')\n")])])]),a("p",[n._v("若使用"),a("code",[n._v("extends")]),n._v("继承接口，则该类可以扩展接口")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("interface IPerson extends IAminal{\n       work(workName:string): string\n}\nclass Human implements IPerson{\n      name: string\n      constructor(name:string){\n          this.name = name\n     }\n\n    eat(food:string){\n           return this.name+'吃'+food\n    }\n\n    work(workName:string){\n          return this.name+'正在'+workName\n    }\n}\n\nconst XiaoMing = new Human('小明')\nXiaoMing.eat('米饭')  //小明吃米饭\nXiaoMing.work('敲代码')  //小明正在敲代码\n")])])]),a("hr"),n._v(" "),a("h2",{attrs:{id:"泛型函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#泛型函数"}},[n._v("#")]),n._v(" 泛型函数")]),n._v(" "),a("p",[n._v("下面这段代码")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("function foo<T>(n1:T, n2:T): T {\n    return n1\n}\n")])])]),a("p",[n._v("表示foo方法执行的时候需要指定一个类型T，两个参数都是T，返回值类型也是T，")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("foo<number>(1, 2)  //合法调用\nfoo<number>('1', 2) //不合法调用\nfoo<string>('1', '2') //合法调用\n")])])]),a("hr"),n._v(" "),a("h2",{attrs:{id:"泛型类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#泛型类"}},[n._v("#")]),n._v(" 泛型类")]),n._v(" "),a("p",[n._v("和泛型函数同理，只是在定义类的时候使用"),a("code",[n._v("<T>")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("class MyList<T> {\n    private list: T[] = []\n    add(value: T):void {\n        this.list.push(value)\n    }\n\n    max():T {\n        let max:T = this.list[0]\n        for (let i = 1; i < this.list.length; i++) {\n            let item: T = this.list[i]\n            if (item > max) {\n                max = item\n            }\n        }\n        return max\n    }\n}\n    let myList2 = new MyList<string>()\n    myList2.add('a')\n    myList2.add('h')\n    myList2.add('b')\n    alert(myList2.max()) //h\n")])])]),a("hr"),n._v(" "),a("h2",{attrs:{id:"泛型接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#泛型接口"}},[n._v("#")]),n._v(" 泛型接口")]),n._v(" "),a("p",[n._v("之前的函数泛型只能返回string类型的值，不够灵活")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("interface fooOption{\n    (v1:string, v2:string):string\n}\n")])])]),a("p",[n._v("进行如下改动")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("interface fooOption{\n    <T>(v1:string, v2:T):T\n}\n\nconst foo:fooOption = function<T>(v1:string, v2:T):T {\n    return v2\n}\nfoo<string>('', '')\n")])])]),a("p",[n._v("给接口中的函数模板添加泛型，可以灵活的返回不同类型。")])])}),[],!1,null,null,null);t.default=e.exports}}]);